# Utility functions for the crystal module of py4DSTEM

import numpy as np
from dataclasses import dataclass
import copy
from py4DSTEM.utils.tqdmnd import tqdmnd


@dataclass
class Orientation:
    """
    A class for storing output orientations, generated by fitting a Crystal
    class orientation plan or Bloch wave pattern matching to a PointList.
    """

    num_matches: int

    def __post_init__(self):
        self.matrix = np.zeros((self.num_matches, 3, 3))
        self.family = np.zeros((self.num_matches, 3, 3))
        self.corr = np.zeros((self.num_matches))
        self.inds = np.zeros((self.num_matches, 2), dtype="int")
        self.mirror = np.zeros((self.num_matches), dtype="bool")
        self.angles = np.zeros((self.num_matches, 3))


@dataclass
class OrientationMap:
    """
    A class for storing output orientations, generated by fitting a Crystal class orientation plan or
    Bloch wave pattern matching to a PointListArray.

    """

    num_x: int
    num_y: int
    num_matches: int

    def __post_init__(self):
        # initialize empty arrays
        self.matrix = np.zeros((self.num_x, self.num_y, self.num_matches, 3, 3))
        self.family = np.zeros((self.num_x, self.num_y, self.num_matches, 3, 3))
        self.corr = np.zeros((self.num_x, self.num_y, self.num_matches))
        self.inds = np.zeros((self.num_x, self.num_y, self.num_matches, 2), dtype="int")
        self.mirror = np.zeros((self.num_x, self.num_y, self.num_matches), dtype="bool")
        self.angles = np.zeros((self.num_x, self.num_y, self.num_matches, 3))

    def set_orientation(self, orientation, ind_x, ind_y):
        # Add an orientation to the orientation map
        self.matrix[ind_x, ind_y] = orientation.matrix
        self.family[ind_x, ind_y] = orientation.family
        self.corr[ind_x, ind_y] = orientation.corr
        self.inds[ind_x, ind_y] = orientation.inds
        self.mirror[ind_x, ind_y] = orientation.mirror
        self.angles[ind_x, ind_y] = orientation.angles

    def get_orientation(self, ind_x, ind_y):
        # Return an orientation from the orientation map
        orientation = Orientation(num_matches=self.num_matches)
        orientation.matrix = self.matrix[ind_x, ind_y]
        orientation.family = self.family[ind_x, ind_y]
        orientation.corr = self.corr[ind_x, ind_y]
        orientation.inds = self.inds[ind_x, ind_y]
        orientation.mirror = self.mirror[ind_x, ind_y]
        orientation.angles = self.angles[ind_x, ind_y]
        return orientation

    # def __copy__(self):
    #     return OrientationMap(self.name)
    # def __deepcopy__(self, memo):
    #     return OrientationMap(copy.deepcopy(self.name, memo))


def sort_orientation_maps(
    orientation_map,
    sort = "intensity",
    cluster_thresh = 0.1,
    ):
    """
    Sort the orientation maps along the ind_match direction, either by intensity
    or by clustering similar angles (greedily, in order of intensity).

    Args:
        orientation_map             Initial OrientationMap
        sort (string):              "intensity" or "cluster" for sorting method.
        cluster_thresh (float):     similarity threshold for clustering method

    Returns:
        orientation_sort            Sorted OrientationMap
    """

    # make a deep copy
    orientation_sort = copy.deepcopy(orientation_map)

    if sort == "intensity":
        for rx, ry in tqdmnd(
            orientation_sort.num_x,
            orientation_sort.num_y,
            desc="Sorting orientations",
            unit=" probe positions",
            # disable=not progress_bar,
            ):
            inds = np.argsort(orientation_map.corr[rx,ry])[::-1]

            orientation_sort.matrix[rx,ry,:,:,:] = orientation_sort.matrix[rx,ry,inds,:,:]        
            orientation_sort.family[rx,ry,:,:,:] = orientation_sort.family[rx,ry,inds,:,:]        
            orientation_sort.corr[rx,ry,:] = orientation_sort.corr[rx,ry,inds]        
            orientation_sort.inds[rx,ry,:,:] = orientation_sort.inds[rx,ry,inds,:]        
            orientation_sort.mirror[rx,ry,:] = orientation_sort.mirror[rx,ry,inds]        
            orientation_sort.angles[rx,ry,:,:] = orientation_sort.angles[rx,ry,inds,:]        

        # elif sort == "cluster":
        #     mask = np.zeros_like(orientation_map.corr, dtype='bool')
        # TODO - implement clustering method for sorting

    else:
        err_msg = "Invalid sorting method: " + sort
        raise Exception(err_msg) 


    return orientation_sort



def axisEqual3D(ax):
    extents = np.array([getattr(ax, "get_{}lim".format(dim))() for dim in "xyz"])
    sz = extents[:, 1] - extents[:, 0]
    centers = np.mean(extents, axis=1)
    maxsize = max(abs(sz))
    r = maxsize / 2
    for ctr, dim in zip(centers, "xyz"):
        getattr(ax, "set_{}lim".format(dim))(ctr - r, ctr + r)


# fmt: off

# a list of symbols for each element
element_symbols = ('H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si',
       'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni',
       'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb',
       'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe',
       'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho',
       'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl',
       'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am',
       'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt',
       'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue', 'Ubn', 'Ubn')

# a dictionary for converting element names into Z
elements = {element_symbols[i]: i + 1 for i in range(len(element_symbols))}
# fmt: on
